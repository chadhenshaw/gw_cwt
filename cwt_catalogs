# Author Alice Heranval, Georgia Institute of Technology
# Last Update Feb 1, 2024

import sys, os, h5py
import numpy as np
from matplotlib import pyplot as plt
from pycbc.catalog import Catalog
from pycbc.catalog import Merger
from pprint import pprint
from pycbc.types.timeseries import *
from . import gw_cwt

os.environ['LAL_DATA_PATH'] = '/scratch/lalsimulation'

fig_width_pt = 1020.
inches_per_pt = 1.0/72.27               # Convert pt to inches
golden_mean = (np.sqrt(5)-1.0)/2.0         # Aesthetic ratio
fig_width = fig_width_pt*inches_per_pt  # width in inches
fig_height = fig_width/golden_mean       # height in inches
fig_size = [fig_width,fig_height]

fontsize = 16
legendfontsize = 14

plot_params={'text.usetex': False,
        'axes.labelsize': fontsize,
        'font.size': fontsize,
        'legend.fontsize': legendfontsize,
        'xtick.labelsize': fontsize,
        'ytick.labelsize': fontsize,
        'figure.figsize': fig_size,
        'font.weight': 'normal'
       }


import pylab
pylab.rcParams.update(plot_params)
pylab.rcParams['axes.linewidth'] = 1
pylab.rc('axes', linewidth=1)

# Function to enhance plot appearance
def touchbox(ax):
    ax.minorticks_on()
    ax.tick_params('both', length=5, width=1, which='major')
    ax.tick_params('both', length=3.5, width=1, which='minor')
    ax.spines['top'].set_linewidth(1)
    ax.spines['bottom'].set_linewidth(1)
    ax.spines['right'].set_linewidth(1)
    ax.spines['left'].set_linewidth(1)
    return

# Function to create a directory for saving
def mkdir(dir_name):
    if os.path.exists(dir_name):
        return False
    temp_path = ''
    for i in range(len(dir_name)):
        if dir_name[i] == "/":
            try:
                os.mkdir(temp_path)
            except:
                pass
        temp_path += dir_name[i]
    return True
            
# mergerDict - get data and return it in a dictionary
# takes in a list of the catalogs from which to retrieve events, and a list of detectors to get information from.
# returns a dictionary mapping:
# 'name' (str) - the name of the event
# 'merger_time' (TimeSeries object) - the time of the merger
# 'strain_info' - a dictionary mapping names of detectors to the whitened data on the merger
# 'catalog' - the name of the catalog where the event is located
def mergerDict(catalogs, ifos):
    print('Retrieving data...')
    numDetections = 0
    data = {}
    print('Loading events...')
    for c in catalogs:
        print(f'Retrieving data from {c}...')
        for e in Catalog(c): # Catalog was imported from pycbc.catalog (see preamble)
            m = Merger(e, c)
            numDetections += 1
            strain_info = {}
            for ifo in ifos:
                try:
                    # add whitened data to strain_info dictionary for event
                    strain_info[ifo] = m.strain(ifo).whiten(4,4)
                    try:
                        e = e[:e.index("-")]
                    except:
                        pass
                except:
                    pass
            data[e] = {'name': e, 'merger_time': m.time, 'strain_info': strain_info, 'catalog': c}
    print(f'Done! retrieved data for {numDetections} detections.')
    return data

# function to create merger dictionary for specific events
def specificMergerDict(events, ifos):
    print('Retrieving data...')
    data = {}
    for eventName in events:
        strain_info = {}
        found = False
        for c in ['GWTC-1-confident', 'GWTC-2.1-confident', 'GWTC-3-confident']:
            if found:
                break
            for e in Catalog(c).names:
                if eventName in e:
                    if eventName != e:
                        print(f'Full name for event {eventName} not entered - set event name to {e}.')
                        eventName = e
                    catalog = c
                    found = True
        m = Merger(eventName, catalog)
        if "-" in eventName:
            eventName = eventName[:eventName.index("-")]
        for ifo in ifos:
            try:
                # add whitened data to strain_info dictionary for event
                strain_info[ifo] = m.strain(ifo).whiten(4,4)
            except:
                pass
        data[eventName] = {'name': eventName, 'merger_time': m.time, 'strain_info': strain_info, 'catalog': c}
    print('Done retrieving data!')
    print()
    return data

# retrieves data from specified catalogs or list of events and adds to an h5py file cwt_data located at the directory specified
# directory is your current working directory if not specified
# returns the h5file path for use with running CWT

def get_data(catalogs=None, ifos=['H1', 'L1', 'V1'], path='', events=[]):
    if path[-1] != '/':
        path += '/'
    finalpath = path
    if path == 'cwt_data' or "/" not in path:
        finalpath = sys.path[0] + path
    if path:
        mkdir(path)
        print(path)
        h5file = path + 'cwt_data'
    else:
        h5file = 'cwt_data'
    if not catalogs:
        if not events:
            sys.exit('did not specify catalog or event.')
        else:
            data = specificMergerDict(events, ifos)
    else:
        data = mergerDict(catalogs, ifos)
    if mkh5(data, h5file) == 'Event exists already.':
        print("One or more events already existed in the h5py file. It is likely that you do not need to update them. New events were saved. If desired, you may create a new h5 file.")
    print()
    if finalpath:
        print('Done! Your h5py file is located in this directory and is called cwt_data:')
        print(finalpath)
        print()
    return h5file

# save whitened data (timeseries.data), times = s_data.sample_times (timestamps for raw strains), timeslice, 
# timeslice.data, timeslice.sample_times
# in the format: {h5py file name}/event/{detector/strain_info/sliced/times etc, other keys}/data
def mkh5(data, path):
    returnStr = ''
    print('Starting to make h5py file')
    try:
        h5f = h5py.File(path, 'a')
    except:
        h5f = h5py.File(path, 'w')
    for event in data:
        event = data[event]
        time = event['merger_time']
        name = event['name']
        if name in h5f.keys():
            returnStr = 'Event exists already.'
            continue
        for key in event:
            if key == 'strain_info':
                for detector in event[key]:
                    path = f'{name}/strain_info/{detector}'
                    timeseries = event[key][detector]
                    odata = timeseries.data #unsliced data
                    otimes = timeseries.sample_times #unsliced data times
                    timeslice = timeseries.time_slice(time - 1, time + 0.5) #slicing it
                    timeslice_times = timeslice.sample_times #sliced data times
                    timeslice_data = timeslice.data #sliced data
                    h5f.create_dataset(f'{path}/unsliced/data', data = odata)
                    h5f.create_dataset(f'{path}/unsliced/times', data = otimes)
                    h5f.create_dataset(f'{path}/sliced/data', data = timeslice_data)
                    h5f.create_dataset(f'{path}/sliced/times', data = timeslice_times)
            else:
                h5f.create_dataset(f'{name}/{key}', data = [event[key]]) # if string, it will be byte and must be decoded
                # use .decode('utf-8')
    h5f.close()
    print('h5py file complete')
    return returnStr

def list_events(h5file):
    try:
        f = h5py.File(h5file, 'r')
        print('Events:')
        print(f.keys())
        f.close()
    except:
        print('File not found.')

# cwt - to run it
# takes in an h5py file path for the event, returned by mkh5() function, and parameters used for build_cwt_dev.
# returns a dictionary mapping each event to a list of tuples for each detector with the detector name, data with CWT run 
# on it, the specific slice of data on which CWT was run, the times corresponding to the data in a TimeSeries object, the 
# top of the scale range, and a tuple with Q and df.
def run_it(h5file, events=None, detectors=None, label=None, Q=8.0, chirp_rate=0.0, f_range=(10.0, 500.0), freq_spacing='Log', n_conv=400, df=None, da=None, f_list=None, Norm=True):
    print('Starting CWT')
    returnDict = {}
    file = h5py.File(h5file, 'r')
    if events:
        for event in events:
            if event not in file.keys():
                print(f'{event} not found. Please double check spelling. Use ' + 'list_events({path/filename}) to check events in file.')
    for event in file.keys():
        if events and event not in events:
            continue
        addList = []
        mergerDict = file[event]
        time = mergerDict['merger_time']
        name = mergerDict['name'][0].decode('utf-8')
        catalog = mergerDict['catalog'][0].decode('utf-8')
        returnDict[name] = {'catalog': catalog}
        for ifo in file[event]['strain_info'].keys():
            if detectors and ifo not in detectors:
                continue
            if ('cwt_result' in file[event].keys()) and (ifo in file[event]['cwt_result'].keys()) and (label in file[event]['cwt_result'][ifo].keys()):
                print(f'Skipping {event} at detector {ifo} - event already contains CWT result.')
            print(f'running CWT on {name}, detector {ifo}...')
            signal = np.array(file[event]['strain_info'][ifo]['sliced']['data'])
            times = np.array(file[event]['strain_info'][ifo]['sliced']['times'])
            # Transform parameters for mother wavelet
            mother_freq= Q/(2*np.sqrt(2)*np.pi) # fiduciary frequency of mother wavelet
            # Build the time-frequency map
            max_scale=512 # top of the scale range
            # freq_range with df and nconv (don't need max_scale) -> specify that logarithmic
            # linear_scale - log frequency
            cwt_result = gw_cwt.build_cwt(signal, times, Q, chirp_rate, f_range, freq_spacing, n_conv, df, da, f_list, Norm)
            times = cwt_result['times']
            addList.append((ifo, cwt_result, signal, times, max_scale, (Q, df)))
        returnDict[name]['cwt_result'] = addList
    print('Done running cwt, saving data...')
    file.close()
    return returnDict

# save map, frequencies, scales
def cwt_savedata(returnDict, h5file, label):
    file = h5py.File(h5file, 'a')
    exist = True
    for event in returnDict:
        for tup in returnDict[event]['cwt_result']:
            result = tup[1]
            detector = tup[0]
            path = f'{event}/cwt_result/{detector}/{label}'
            try:
                file.create_dataset(f'{path}/map', data = result['map'])
                file.create_dataset(f'{path}/frequencies', data = result['frequencies'])
                file.create_dataset(f'{path}/scales', data = result['scales'])
                exist = False
            except:
                pass
    file.close()
    if not returnDict:
        print('No events were found.')
        return False
    if exist:
        print(f'CWT results already exist for all events using changed parameter(s) {label}. No changes were made.')
    else:
        return True
    
# Runs cwt and saves to an h5py file.
# label is desired parameter for organization. Specify param and value. Ex: 'Q6'
def run_cwt(h5file, events=None, detectors=['H1','L1','V1'], label=None, Q=8.0, chirp_rate=0.0, path='', event=None, f_range=(10.0, 500.0), freq_spacing='Log', n_conv=400, df=None, da=None, linear_freq=False, f_list=None, Norm=True):
    if not label:
        label = f'Q{Q}_default'
    if events and type(events) != list:
        events = [events]
    cwt_dict = run_it(h5file, events, detectors, label, Q, chirp_rate, f_range, freq_spacing, n_conv, df, da, f_list, Norm)
    a = cwt_savedata(cwt_dict, h5file, label)
    if a:
        print(f'Done! Data saved to {h5file}')

# function to plot CWT results
# fig_width in inches
# label can be used to sort by a certain parameter, for example if you want to sort by Qs specify the Q value
# of the parameter by calling label 'Q[num]' ex: 'Q6'
def plot_cwt(h5file, events_to_plot=None, label=None, detectors_to_plot=['H1','L1','V1'], savefig=True, savefigpath='', freq_to_plot=(10, 300), plot_domain=(-0.5, 0.2), fig_width=8.0):
    existed = []
    if not label:
        print('No subfolder specified. Plots will be created for all default CWT results existing for these events. If desired, you may specify a label to tell the code which results to use.')
    f = h5py.File(h5file, 'r')
    if savefigpath:
        if savefigpath[-1] != "/":
            savefigpath += "/"
    for event in f.keys():
        if events_to_plot and event not in events_to_plot:
            continue
        for detector in f[event]['cwt_result'].keys():
            if detector not in detectors_to_plot:
                continue
            for param in f[event]['cwt_result'][detector].keys():
                if (label and param != label) or ('default' in param):
                    continue
                if savefig:
                    if label:
                        mkdir(savefigpath + event + "/" + detector + "/" + label + "/")
                        figpath = f'{savefigpath}{event}/{detector}/{label}/{event}_{detector}{label}.png'
                        if os.path.exists(figpath):
                            print(f'{event} at {detector} already exists in this directory at specified folder {label}. Skipping plot.')
                            existed.append(f'{event}_{detector}{label}')
                            continue
                    else:
                        mkdir(savefigpath + event + "/" + detector + "/")
                        figpath = f'{savefigpath}{event}/{detector}/{event}_{detector}{param}.png'
                        if os.path.exists(figpath):
                            print(f'{event} at {detector} using {param} already exists in this directory. Skipping plot.')
                            existed.append(f'{event}_{detector}{param}')
                            continue
                cwt_result = f[event]['cwt_result'][detector][param]
                wfreqs = np.array(cwt_result['frequencies'])
                fmap = np.array(cwt_result['map'])
                scales = np.array(cwt_result['scales'])
                times = np.array(f[event]['strain_info'][detector]['sliced']['times'])
                signal = np.array(f[event]['strain_info'][detector]['sliced']['data'])
                merger_time = float(np.array(f[event]['merger_time'][0]))
                golden_ratio = 1.61803398875
                fig_height = fig_width / golden_ratio
                plt.close('all')
                fig, ax = plt.subplots(figsize=(fig_width, fig_height),sharex=True, ncols=1, nrows=1)
                fig.patch.set_facecolor('white')
                # shifting times so merger is at t = 0 seconds
                times = times - merger_time
                #
                # Spectrograms
                #
                spec = ax.pcolormesh(times, wfreqs, fmap, rasterized=False, vmin=0, vmax=1, shading='auto', cmap='viridis')
                ax.set_ylabel('Frequency [Hz]', fontsize=10)
                ymin, ymax = freq_to_plot
                ax.set_ylim(ymin, ymax)
                ax.tick_params(axis='y',labelsize=10)
                ax.set_xlabel('Time from merger [s]', fontsize=10)
                ax.set_xlim(plot_domain)
                ax.tick_params(axis='x',labelsize=10)
                touchbox(ax)
                clb = fig.colorbar(spec, ax=ax, shrink=0.95, pad=0.05)
                clb.ax.set_title(r'$T\left(t, f\right)$', fontsize=10, pad=5)
                clb.ax.tick_params(labelsize=10)
                if savefig:
                    if label:
                        plt.savefig(figpath, format='png', bbox_inches='tight')
                        print(f'Saved figure for merger {event} at {detector}.')
                    else:
                        plt.savefig(figpath, format='png', bbox_inches='tight')
                        print(f'Saved figure for merger {event} at {detector}.')
                else:
                    print(f'Done with merger {event} at {detector}.')
                    plt.show()
    if existed:
        print()
        print('Done! The following plots already existed in their intended directories and were not replaced: ')
        for event in existed:
            print(event)
    else:
        print()
        print('Done!')
    print()
    f.close()
